import torch
from torch.utils.data import Dataset
from torch_geometric.data import Data
import os
import numpy as np
from rdkit import Chem
from rdkit.Chem import AllChem

class OrpheusDataset(Dataset):
    def __init__(self, data_dir, protein_pdb_map=None):
        """
        data_dir: Directory containing .pt files generated by generate_dataset.py
        protein_pdb_map: Dict mapping sample_id to protein PDB path (optional, for future use)
        """
        self.data_dir = data_dir
        self.files = [f for f in os.listdir(data_dir) if f.endswith('.pt')]
        print(f"OrpheusDataset: Found {len(self.files)} samples.")
        
        # Atom feature mapping (Simple one-hot for C, N, O, S, F, P, Cl, Br, I)
        self.atom_types = ['C', 'N', 'O', 'S', 'F', 'P', 'Cl', 'Br', 'I']
        self.atom_map = {sym: i for i, sym in enumerate(self.atom_types)}

    def __len__(self):
        return len(self.files)

    def __getitem__(self, idx):
        filename = self.files[idx]
        path = os.path.join(self.data_dir, filename)
        
        # Load Labels
        data = torch.load(path)
        
        traj = data['trajectory'] # (33, N, 3)
        pocket_center = data['pocket_center']
        
        # Center coordinates to pocket center
        # This is crucial for numerical stability
        traj = traj - pocket_center
        
        pos_input = traj[0]       # Initial pose (Stage 1 start)
        pos_target = traj[-1]     # Final pose (Stage 3 end)
        
        deformation_label = data['deformation'] # (32, N) -> We can take mean or max, or use full sequence
        # For the student, let's predict the "Total Deformation Potential"
        # So we sum or mean over time.
        deformation_target = deformation_label.mean(dim=0) # (N,)
        
        direction_label = data['direction'] # (32, N)
        direction_target = direction_label.mean(dim=0) # (N,)
        
        # Node Features (Atomic Numbers)
        # Map atomic number to index
        # C=6, N=7, O=8, S=16, F=9, P=15, Cl=17, Br=35, I=53
        atom_map = {6: 0, 7: 1, 8: 2, 16: 3, 9: 4, 15: 5, 17: 6, 35: 7, 53: 8}
        
        def get_node_feats(atoms, is_ligand):
            feats = []
            for atom_num in atoms:
                idx = atom_map.get(atom_num.item(), 9) # 9 is 'Other'
                vec = torch.zeros(17) # 16 types + 1 is_ligand
                vec[idx] = 1.0
                vec[16] = 1.0 if is_ligand else 0.0
                feats.append(vec)
            return torch.stack(feats)

        if 'atomic_numbers' in data:
            ligand_atoms = data['atomic_numbers']
            ligand_feats = get_node_feats(ligand_atoms, is_ligand=True)
        else:
            # Fallback
            num_atoms = pos_input.shape[0]
            ligand_feats = torch.zeros((num_atoms, 17))
            ligand_feats[:, 0] = 1.0 # Carbon
            ligand_feats[:, 16] = 1.0 # Is Ligand

        # Pocket Features
        if 'pocket_pos' in data and len(data['pocket_pos']) > 0:
            pocket_pos = data['pocket_pos'] - pocket_center # Center it!
            
            # Check for NaNs
            if torch.isnan(pocket_pos).any():
                print(f"Warning: NaN in pocket_pos for {filename}. Skipping pocket.")
                pocket_pos = torch.tensor([])
                pocket_atoms = torch.tensor([])
            else:
                pocket_atoms = data['pocket_atoms']
        else:
            pocket_pos = torch.tensor([])
            pocket_atoms = torch.tensor([])

        if len(pocket_pos) > 0:
            pocket_feats = get_node_feats(pocket_atoms, is_ligand=False)
            
            # Combine
            x = torch.cat([pos_input, pocket_pos], dim=0)
            h = torch.cat([ligand_feats, pocket_feats], dim=0)
            
            # Mask to identify ligand nodes (for loss and updates)
            ligand_mask = torch.zeros(x.shape[0], dtype=torch.bool)
            ligand_mask[:len(pos_input)] = True
            
        else:
            # No pocket found (should not happen if generated correctly)
            x = pos_input
            h = ligand_feats
            ligand_mask = torch.ones(x.shape[0], dtype=torch.bool)

        # Edges
        # 1. Covalent Bonds (if available)
        edge_index_list = []
        edge_attr_list = []
        
        if 'bond_index' in data and data['bond_index'] is not None and data['bond_index'].shape[1] > 0:
            bonds = data['bond_index']
            # Bonds are only for ligand atoms (indices 0 to N-1)
            # No offset needed as ligand is at the start of x
            edge_index_list.append(bonds)
            
            # Attribute: [1, 0, 0, 0] for Covalent
            attr = torch.tensor([1.0, 0.0, 0.0, 0.0]).repeat(bonds.shape[1], 1)
            edge_attr_list.append(attr)
            
        # 2. KNN Graph (Interaction Edges)
        # We want KNN for:
        # - Ligand internal (long range)
        # - Ligand <-> Pocket
        
        # A. Ligand Internal KNN (to maintain shape)
        ligand_knn = self.build_knn_graph(pos_input, k=8)
        edge_index_list.append(ligand_knn)
        attr = torch.tensor([0.0, 0.0, 1.0, 0.0]).repeat(ligand_knn.shape[1], 1) # Type 2: Internal KNN
        edge_attr_list.append(attr)

        # B. Ligand-Pocket Interaction (Crucial for pulling!)
        if len(pocket_pos) > 0:
            # Ligand indices: 0 to N_L-1
            # Pocket indices: N_L to N_L+N_P-1
            N_L = len(pos_input)
            pkt_idx_offset = N_L
            
            # Calculate dists between Ligand and Pocket
            # (N_L, N_P)
            dists = torch.cdist(pos_input, pocket_pos)
            
            # For each ligand atom, find k nearest pocket atoms
            k_inter = min(16, len(pocket_pos))
            _, indices = dists.topk(k_inter, largest=False, dim=1) # (N_L, k)
            
            src_list = []
            dst_list = []
            for i in range(N_L):
                for j_idx in indices[i]:
                    pkt_node_idx = j_idx.item() + pkt_idx_offset
                    
                    # Add bidirectional edges
                    src_list.append(i)
                    dst_list.append(pkt_node_idx)
                    
                    src_list.append(pkt_node_idx)
                    dst_list.append(i)
            
            inter_edges = torch.tensor([src_list, dst_list], dtype=torch.long)
            edge_index_list.append(inter_edges)
            
            # Attribute for Interaction
            attr = torch.tensor([0.0, 1.0, 0.0, 0.0]).repeat(inter_edges.shape[1], 1) # Type 1: Interaction
            edge_attr_list.append(attr)
        
        if len(edge_index_list) > 0:
            edge_index = torch.cat(edge_index_list, dim=1)
            edge_attr = torch.cat(edge_attr_list, dim=0)
        else:
            edge_index = torch.zeros((2, 0), dtype=torch.long)
            edge_attr = torch.zeros((0, 4))
            
        # Store bond_index separately for Bond Loss
        bond_index_attr = data['bond_index'] if 'bond_index' in data and data['bond_index'] is not None else torch.empty((2, 0), dtype=torch.long)
        
        return Data(
            x=x,
            y=pos_target, # This is ONLY for ligand. We need to handle this in loss.
            h=h,
            edge_index=edge_index,
            edge_attr=edge_attr,
            deformation=deformation_target,
            direction=direction_target,
            ligand_mask=ligand_mask,
            bond_index=bond_index_attr
        )

    def build_knn_graph(self, pos, k=5):
        # Simple brute force KNN
        # pos: (N, 3)
        num_nodes = pos.shape[0]
        # Ensure k is not larger than num_nodes - 1
        k = min(k, num_nodes - 1)
        
        if k <= 0:
            return torch.zeros((2, 0), dtype=torch.long)
            
        dist = torch.cdist(pos, pos)
        # Get top k (excluding self)
        _, indices = dist.topk(k + 1, largest=False)
        
        src_list = []
        dst_list = []
        for i in range(pos.shape[0]):
            for j in indices[i, 1:]: # Skip self
                src_list.append(i)
                dst_list.append(j.item())
                
        return torch.tensor([src_list, dst_list], dtype=torch.long)

